<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>idea使用lombok报错</title>
      <link href="/2023/05/01/idea-lombok-config/"/>
      <url>/2023/05/01/idea-lombok-config/</url>
      
        <content type="html"><![CDATA[<h2 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java: You aren&#x27;t using a compiler supported by lombok, so lombok will not work and has been disabled.</span><br><span class="line">Your processor is: com.sun.proxy.$Proxy24</span><br><span class="line">Lombok supports: sun/apple javac 1.6, ECJ</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="打开IDEA的配置"><a href="#打开IDEA的配置" class="headerlink" title="打开IDEA的配置"></a>打开IDEA的配置</h2><p>Setting -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Shared build process VM options</p><h2 id="加入以下内容"><a href="#加入以下内容" class="headerlink" title="加入以下内容"></a>加入以下内容</h2><p>-Djps.track.ap.dependencies&#x3D;false</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务-分布式事务</title>
      <link href="/2021/09/17/distributed-transaction/"/>
      <url>/2021/09/17/distributed-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><div class="note info"><h5 id="Q：分布式事务主要解决的问题是什么？"><a href="#Q：分布式事务主要解决的问题是什么？" class="headerlink" title="Q：分布式事务主要解决的问题是什么？"></a>Q：分布式事务主要解决的问题是什么？</h5><p>A：分布式场景下的【原子性】</p></div><span id="more"></span><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction1.png" width=300/>小明买口红遇到的问题：两个色号的口红都想要，必须保证【要么两只都买到，要么两只都不买】如何解决?<p>从未听说过分布式事务概念的人也能想出办法：提前预定。</p><ol><li>两家⻔店都预定成功：分别去购买(要求预定后一定能 成功购买)。 </li><li>任意⻔店预定不成功：取消已预定成功的⻔店，不去购买。<br>上述方案即是分布式事务的原型，也是核心思想&#x3D;&#x3D;&gt;两阶段提交</li></ol><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction2.png" width=600/><h3 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h3><p>首先，当参与者投票“是”时，它做出了肯定提交的承诺(尽管还取决于其他的参与者的投票，协调者才能做出最后决断)。<br>其次，协调者做出了提交(或者放弃)的决定，这个决定也是不可撤销。<br>正是这两个承诺确保了2PC的原子性(而单节点原子提交其实是将两个事件合二为一，写入事务日志即提交)</p><h3 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h3><div class="note info"><h4 id="两阶段提交（2PC）-VS-两阶段加锁（2PL）"><a href="#两阶段提交（2PC）-VS-两阶段加锁（2PL）" class="headerlink" title="两阶段提交（2PC） VS 两阶段加锁（2PL）"></a>两阶段提交（2PC） VS 两阶段加锁（2PL）</h4><p>两阶段提交（2PC）在分布式数据库中负责原子提交<br>两阶段加锁（2PL）则提供可串行化隔离</p></div><h2 id="协调者发生故障"><a href="#协调者发生故障" class="headerlink" title="协调者发生故障"></a>协调者发生故障</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction3.png" width=600/><div class="note warning"><p>2PC能够顺利完成的唯一方法是等待协调者恢复。</p></div><h2 id="分布式事务分类"><a href="#分布式事务分类" class="headerlink" title="分布式事务分类"></a>分布式事务分类</h2><table><thead><tr><th align="left">事务类型</th><th align="left">具体说明</th></tr></thead><tbody><tr><td align="left">数据库内部的分布式事务</td><td align="left">某些分布式数据库支持跨数据库节点的内部事务。<br>此时 ，所有参与节点都运行着相同的数据库软件。<br>例如， MySQL Cluster的NDB存储引擎就支持这样的内部分布式事务。</td></tr><tr><td align="left">异构分布式事务</td><td align="left">在异构分布式事务中，存在两种或两种以上不同的参与者实现技术。<br>例如来自不同供应商的数据库，甚至是非数据库系统(如消息中间件)。<br>即使是完全不同的系统，跨系统的分布式事务业必须确保原子提交。</td></tr></tbody></table><div class="note danger"><p>Q：分布式事务不用两阶段提交，行不行？</p></div><h1 id="分布式事务的具体实现方案"><a href="#分布式事务的具体实现方案" class="headerlink" title="分布式事务的具体实现方案"></a>分布式事务的具体实现方案</h1><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><blockquote><p>TCC 是一种成熟的分布式事务解决方案，属于柔性补偿型，优点在于容易理解。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction4.png" width=400/><p>TCC 是服务层面的2阶段编程模型。业务需要编码实现3个接口(Try、Confirm、Cancel) :</p><ul><li>Try 操作作为一阶段，主要负责资源的检查和预留。 </li><li>Confirm&#x2F;Cancel  同为二阶段<br>当一阶段Try方法执行成功是调用Confirm方法提交预留的资源，执行真正的业务。<br>一阶段调用失败时则调用Cancel方法，对Try方法中预留的资源进行释放。</li></ul><h4 id="场景举例：用户将自己【活期账户】中的30元转到【理财账户】中。"><a href="#场景举例：用户将自己【活期账户】中的30元转到【理财账户】中。" class="headerlink" title="场景举例：用户将自己【活期账户】中的30元转到【理财账户】中。"></a>场景举例：用户将自己【活期账户】中的30元转到【理财账户】中。</h4><table><thead><tr><th align="left">系统</th><th align="left">阶段</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">活期账户</td><td align="left">Try</td><td align="left">检查资金是否充足<br>若充足，资金预扣（冻结转账资金）<br>否则返回错误码</td></tr><tr><td align="left">活期账户</td><td align="left">Confirm</td><td align="left">执行：可用资金 &#x3D; 可用资金 - 转账金额</td></tr><tr><td align="left">活期账户</td><td align="left">Cancel</td><td align="left">冻结资金解冻</td></tr><tr><td align="left">理财账户</td><td align="left">Try</td><td align="left">检查当前账户是否可用<br>若可用，资金预加（预加的金额不可用于消费）<br>否则返回错误码</td></tr><tr><td align="left">理财账户</td><td align="left">Confirm</td><td align="left">执行：可用资金 &#x3D; 可用资金 + 转账金额</td></tr><tr><td align="left">理财账户</td><td align="left">Cancel</td><td align="left">预加资金解除</td></tr></tbody></table><p>活期账户各阶段流程如下所示【理财账户同理】：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction5.png" width=600/></p><h2 id="TXC"><a href="#TXC" class="headerlink" title="TXC"></a>TXC</h2><p>TXC将分布式事务操作下放至JDBC层，通过SQL拦截改写实现数据正向提交和逆向补偿。</p><ul><li>优点：业务基本无需改造。 </li><li>缺点：只支持数据库。<br>TXC是除TCC外另一种应用较为广泛的分布式事务实现。<img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction7.png" width=600/></li></ul><h2 id="sage"><a href="#sage" class="headerlink" title="sage"></a>sage</h2><p>saga一般用于处理⻓活事务，即链路较⻓的事务性操作，也是通过正向操作+逆向补偿的思想实现事务，与TCC较为类似。<br>saga与TCC的最大不同是saga没有try阶段，即没有预留资源的操作，可用于较为简单的业务，但也由于没有预留资源，因此补偿动作也更麻烦。</p><h4 id="举个例子：购买商品"><a href="#举个例子：购买商品" class="headerlink" title="举个例子：购买商品"></a>举个例子：购买商品</h4><table><thead><tr><th align="left">正常流程</th><th align="left">异常回滚</th></tr></thead><tbody><tr><td align="left"><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction8.png" width=300/></td><td align="left"><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/distributed-transaction/distributed-transaction9.png" width=300/></td></tr></tbody></table><p>Saga 的适用场景</p><ul><li>业务流程多、业务流程长 </li><li>无法抽象出 TCC 的 Try 阶段，但是可以很方便地实现补偿方法</li></ul><p>Saga 相比 TCC 的优势</p><ul><li>一阶段提交本地数据库事务，无锁，高性能 </li><li>没有预留动作，易于改造兼容老的业务逻辑 </li><li>补偿服务即正向服务的“反向”，易于理解，易于实现</li></ul><div class="note warning"><h4 id="分布式事务不用两阶段提交，使用一阶段提交，行不行？【本质只是为了实现原子性-可中止性-方便回滚】"><a href="#分布式事务不用两阶段提交，使用一阶段提交，行不行？【本质只是为了实现原子性-可中止性-方便回滚】" class="headerlink" title="分布式事务不用两阶段提交，使用一阶段提交，行不行？【本质只是为了实现原子性-&gt;可中止性-&gt;方便回滚】"></a>分布式事务不用两阶段提交，使用一阶段提交，行不行？【本质只是为了实现原子性-&gt;可中止性-&gt;方便回滚】</h4><p>某些情况下可行：小明买口红的例子，不预定，直接购买，如果任意一家店缺货，则将已购买的商品退货。（很方便地实现补偿方法）。<br>转账逻辑不可行：比如A-&gt;B转账，一阶段提交之后，B把钱花了，此时执行回滚，B已经没钱归还给A了。</p></div>]]></content>
      
      
      <categories>
          
          <category> distributed </category>
          
          <category> transaction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务-概览</title>
      <link href="/2021/09/17/transaction/"/>
      <url>/2021/09/17/transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><div class="note info"><h4 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h4><p>事务不是一个天然存在的东西，它是被人为创造出来，目的是简化应用层的编程模型。<br>有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的井发性问题，这些都可以交给数据库来负责处理，我们称之为安全性保证。<br>即：事务是一种数据安全性保证的机制。</p></div><span id="more"></span><h2 id="安全性保证"><a href="#安全性保证" class="headerlink" title="安全性保证"></a>安全性保证</h2><table><thead><tr><th align="left">分类</th><th align="left">说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">原子性( Atomicity)</td><td align="left">在出错时中止事务，并将部分完成的写入全部丢弃</td><td align="left">处理异常</td></tr><tr><td align="left">一致性( Consistency)</td><td align="left">本质上要求应用层来维护状态一致(或者恒等)</td><td align="left"></td></tr><tr><td align="left">隔离性( Isolation)</td><td align="left">并发执行的多个事务相互隔离，它们不能互相交叉</td><td align="left">处理并发</td></tr><tr><td align="left">持久性( Durability)</td><td align="left">一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失</td><td align="left"></td></tr></tbody></table><blockquote><p>原子性，隔离性和持久性是数据库自身的属性，而 ACID中的一致性更多是应用层的属性。<br>应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不拥于数据库。<br>因此，字母C其实并不应该属于【事务的安全性保证】。</p></blockquote><h2 id="事务隔离级别分类"><a href="#事务隔离级别分类" class="headerlink" title="事务隔离级别分类"></a>事务隔离级别分类</h2><table><thead><tr><th align="left"></th><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">无隔离</td><td align="left">读未提交（Read uncommitted）</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">弱隔离</td><td align="left">读已提交（Read committed）</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">弱隔离</td><td align="left">可重复读（Repeatable read）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">可能</td></tr><tr><td align="left">强隔离</td><td align="left">串行化（Serializable ）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table><div class="note danger"><p>Q：读未提交（Read uncommitted）存在的意义是什么？<br>A：1.防止脏写(下面会讲到)；2.保证原子性(发生错误可以回滚)</p></div><h1 id="读-未提交"><a href="#读-未提交" class="headerlink" title="读-未提交"></a>读-未提交</h1><p>读未提交可以提供以下保证：<br>写数据库肘，只会覆盖已成功提交的数据(防止“脏写”)</p><p>首先来看一个【脏写】的示例：<br>买车的时候，需要同时更新【车辆，发票】。<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/car_invoices.png" width=600/><br>该例最终会导致：Alice拥有发票，Bob拥有车辆。<br>而【读-未提交】可以避免该问题。</p><h1 id="读-提交"><a href="#读-提交" class="headerlink" title="读-提交"></a>读-提交</h1><p>读-提交是最基本的的事务隔离级别，它只提供以下两个保证 :<br>读数据库肘，只能看到已成功提交的数据(防止“脏读”)。<br>写数据库肘，只会覆盖已成功提交的数据(防止“脏写”)。</p><p>【防止脏写】上面我们已经介绍过了，结下来看一下【防止脏读】：<br>举例：用户2只有在用户1的事务提交之后才能看到x的新值<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/avoid_uncommited_read.png" width=500/></p><h2 id="实现读-提交"><a href="#实现读-提交" class="headerlink" title="实现读-提交"></a>实现读-提交</h2><table><thead><tr><th align="left">实现方式</th><th align="left">说明</th><th align="left">推荐</th></tr></thead><tbody><tr><td align="left">行锁</td><td align="left">修改记录需要获取锁<br>读取记录需要获取锁</td><td align="left">不推荐<br>因为有可能写事件很耗时，导致读事件长期排队</td></tr><tr><td align="left">多版本</td><td align="left">对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。<br>在事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值。</td><td align="left">推荐<br>性能更优，只读事务不受写事件影响。</td></tr></tbody></table><div class="note danger"><p>Q1：多版本需要锁吗？<br>A1：需要<br>Q2：通过行锁可以达到上图所示的效果吗（第二次get x 能获取到 2 吗）？<br>A2：不能（因为用户1在进行set x&#x3D;3时，拿到了x的锁，此时用户2的第二次get x，读操作拿不到锁，会被阻塞）</p></div><h1 id="可重复读（快照隔离）"><a href="#可重复读（快照隔离）" class="headerlink" title="可重复读（快照隔离）"></a>可重复读（快照隔离）</h1><div class="note warning"><p>如何定义可重复读？<br>两次读取同一个对象，读到的结果一致？片面</p></div><p>首先举一个不可重复读的例子：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/cannot_repeated_read.png" width=600/><br>假设Alice在银行有1000美元的存款，分为两个账户，每个500美元。<br>现在有这样一笔转账交易：从账户1转100美元到账户2。【可以理解为定投100到理财账户】<br>如果在她提交转账请求之后，而银行数据库系统执行转账的过程中间，来查看两个账户的余额，她有可能会看到账号2在收到转账之前的余额(500美元)，和账户1在完成转账之后的余额(400美元)。<br>对于Alice巳来说，貌似她的账户总共只有900美元，有100美元消失了。<br>这种异常现象被称为不可重复读取(nonrepeatable read)或读倾斜(read skew)。<br>可重复读就是为了解决这种问题。</p><h2 id="实现可重复读（快照级别隔离）"><a href="#实现可重复读（快照级别隔离）" class="headerlink" title="实现可重复读（快照级别隔离）"></a>实现可重复读（快照级别隔离）</h2><p>快照级别隔离的实现通常采用写锁来防止脏写(参阅前面的“实现读-提交”)，这意味着正在进行写操作的事务会阻止同一对象上的其他事务。<br>但是，读取则不需要加锁。<br>从性能角度看，快照级别隔离的一个关键点是读操作不会阻止写操作，反之亦然。<br>如果只是为了提供读-提交级别隔离，而不是完整的快照级别隔离，则只保留对象的两个版本就足够了:一个己提交的旧版本和尚未提交的新版本。<br>所以，支持快照级别隔离的存储引擎往往直接采用MVCC来实现读提交隔离。<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/repeatedable_read_impl.png" width=600/></p><div class="note info"><h4 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h4><p>通过上图我们可以看出，事务读数据库时，通过事务ID可以决定哪些对象可见，哪些不可见。<br>当以下两个条件都成立，则数据对象对事务可见:<br>1.事务开始的时刻，创建该对象的事务已经完成了提交。<br>2.对象没有被标记为删除；或者即使标记了，但删除事务在当前事务开始的时刻还没有完成提交。<br>可以看出，在事务的开始时刻就已经确定了哪些对象可见，哪些不可见。</p></div><h1 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h1><div class="note danger"><h5 id="Q：【可重复读】级别，还有什么解决不了的问题吗？"><a href="#Q：【可重复读】级别，还有什么解决不了的问题吗？" class="headerlink" title="Q：【可重复读】级别，还有什么解决不了的问题吗？"></a>Q：【可重复读】级别，还有什么解决不了的问题吗？</h5><p>A：幻读 + 写倾斜</p></div><p>举例：医院值班室需要保证至少要有1人在岗，现在A和B都在值班室，他们都认为现在有两个人在，自己下班后，还有另一个人在值班室，满足值班室最低1人在岗条件。所以他们都发起了下班请求：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/virtual_read_of_two_doctor.png" width=600/></p><div class="note warning"><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>幻读：在一个事务中的写入改变了另一个事务查询结果的现象。（从隔离性的角度来说，这种改变确实是不应该被感知到的）<br>写倾斜：事务首先查询数据，根据返回的结果而作出某些决定，然后修改数据库 。当事务提交时，支持决定的前提条件已不再成立。</p></div><h2 id="串行化实现方案"><a href="#串行化实现方案" class="headerlink" title="串行化实现方案"></a>串行化实现方案</h2><table><thead><tr><th align="left">方案</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">严格串行执行</td><td align="left">如果每个事务的执行速度非常快，且单个CPU核可以满足事务的吞吐量要求，严格串行执行是一个非常简单有效的方案。</td></tr><tr><td align="left">两阶段加锁</td><td align="left">几十年来，这一直是实现可串行化的标准方式，但还是有很多系统出于性能原因而放弃使用它。</td></tr><tr><td align="left">可串行化的快照隔离 (SSI)</td><td align="left">一种最新的算法，可以避免前面方法的大部分缺点。<br>它秉持乐观预期的原则，允许多个事务并发执行而不互相阻塞。<br>仅当事务尝试提交肘，才检查可能的冲突，如果发现违背了串行化，则某些事务会被中止。</td></tr></tbody></table><h3 id="1-严格串行执行（Redis为代表）"><a href="#1-严格串行执行（Redis为代表）" class="headerlink" title="1.严格串行执行（Redis为代表）"></a>1.严格串行执行（Redis为代表）</h3><p>解决井发问题最直接的方法是避免井发：即在一个线程上按顺序方式每次只执行一个事务。<br>串行执行小结当满足以下约束条件时，串行执行事务可以实现串行化隔离:<br>事务必须简短而高效，否则一个缓慢的事务会影响到所有其他事务的执行性能。<br>仅限于活动数据集完全可以加载到内存的场景。有些很少访问的数据可能会被移到磁盘，但万一单线程事务需要访问它，就会严重拖累性能。<br>写入吞吐量必须足够低，才能在单个CPU核上处理，否则就需要采用分区，最好没有跨分区事务。<br>跨分区事务虽然也可以支持，但是占比必须很小。<br>单线程不能利用多核CPU，这种方案一般不考虑！<br>Q：Redis多分片场景下，支持事务吗？ N</p><h3 id="2-两阶段加锁（two-phase-locking）"><a href="#2-两阶段加锁（two-phase-locking）" class="headerlink" title="2.两阶段加锁（two-phase locking）"></a>2.两阶段加锁（two-phase locking）</h3><p>如果事务A已经读取了某个对象，此时事务B想要写入该对象，那么B必须等到A提交或中止之才能继续。以确保B不会在事务A执行的过程中间去修改对象。<br>如果事务A已经修改了对象，此时事务B想要读取该对象，则B必须等到A提交或中止之后才能继续。对于2PL，不会出现读到旧值的情况。<br>实现两阶段加锁<br>目前，2PL已经用于MySQL(InnoDB)和SQLServer中的“可串行化隔离”，以及DB2中的“可重复读隔离”。<br>此时数据库的每个对象都有一个读写锁来隔离读写操作。即锁可以处于共享模式或独占模式：</p><ol><li>如果事务要读取对象，必须先以共享模式获得锁。可以有多个事务同时获得一个对象的共享锁，但是如果某个事务已经获得了对象的独占锁，则所有其他事务必须等待。 </li><li>如果事务要修改对象，必须以独占模式获取锁。不允许多个事务同时持有锁(包括共享或独占模式)，换言之，如果对象上已被加锁，那么修改事务必须等待。 </li><li>如果事务首先读取对象，然后尝试写入对象，则需要将共享锁升级为独占锁。升级锁的流程等价于直接获得独占锁。 </li><li>事务获得锁之后，一直持有锁直到事务结束(包括提交或中止)。<br>这也是名字“两阶段”的来由，在第一阶段即事务执行之前要获取锁，第二阶段(即事务结束时)则释放锁。</li></ol><h4 id="锁过多会导致的问题：死锁"><a href="#锁过多会导致的问题：死锁" class="headerlink" title="锁过多会导致的问题：死锁"></a>锁过多会导致的问题：死锁</h4><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/much_lock.png" width=600/>数据库系统会自动检测事务之间的死锁情况，并强行中止其中的一个以打破僵局，这样另一个可以继续向前执行。<div class="note danger"><p>但我们需要考虑的问题是：僵局打破后，线程1的数据就应该丢掉吗？应用层是否需要做重试？</p></div><h4 id="两阶段加锁升级版"><a href="#两阶段加锁升级版" class="headerlink" title="两阶段加锁升级版"></a>两阶段加锁升级版</h4><table><thead><tr><th align="left"></th><th align="left">谓词锁</th><th align="left">索引区间锁</th></tr></thead><tbody><tr><td align="left">功能介绍</td><td align="left">它的作用类似于之前描述的共享&#x2F;独占锁，而区别在于，它并不属于某个特定的对象(如表的某一行)，而是作用于满足某些搜索条件的所有查询对象。谓词锁会限制如下访问:<br>如果事务A想要读取某些搞足匹配条件的对象，例如采用SELECT查询，它必须以共享模式获得查询条件的谓词锁。<br>如果另一个事务B正持有任何一个匹配对象的互斥锁，那么A必须等到B释放锁之后才能继续执行查询。<br>如果事务A想要插入、更新或删除任何对象，则必须首先检查所有旧值和新值是否与现有的任何谓词锁匹配(即冲突)。如果事务B持有这样的谓词锁，那么A必须等到B完成提交(或中止)后才能继续。</td><td align="left">本质上它是对谓词锁的简化或者近似，简化谓词锁的方式是将其保护的对象扩大化，首先这肯定是安全的。</td></tr><tr><td align="left">优点</td><td align="left">这里的关键点在于， 谓词锁甚至可以保护数据库中那些尚不存在但可能马上会被插入的对象(幻读)。</td><td align="left">相比较于谓词锁，开销低得多。</td></tr><tr><td align="left">缺点</td><td align="left">性能不佳:如果活动事务中存在许多锁，那么检查匹配这些锁就变得非常耗时。</td><td align="left">索引区间锁不像谓词锁那么精确，定更大范围的对象，而超出了串行化所要求的部分。</td></tr><tr><td align="left">备注</td><td align="left"></td><td align="left">如果没有合适的索引可以施加区间锁，则数据库可以回退到对整个表加锁。这种方式的性能肯定不好，它甚至会阻止所有其他事务的写操作，但的确可以保证安全性。</td></tr></tbody></table><h3 id="3-可串行化的快照隔离-Serializable-Snapshot-Isolation，SSI"><a href="#3-可串行化的快照隔离-Serializable-Snapshot-Isolation，SSI" class="headerlink" title="3.可串行化的快照隔离(Serializable Snapshot Isolation，SSI)"></a>3.可串行化的快照隔离(Serializable Snapshot Isolation，SSI)</h3><p>悲观与乐观的并发控制<br>两阶段加锁是一种典型的悲观井发控制机制<br>为了提供可串行化的快照隔离，数据库必须检测事务是否会修改其他事务的查询结果，并在此情况下中止写事务。<br>数据库如何知道查询结果是否发生了改变呢?可以分以下两种情况:</p><ol><li>读取是否作用于一个(即将)过期的MVCC对象(读取之前已经有未提交的写入)。 </li><li>检查写人是否影响即将完成的读取(读取之后，又有新的写入)。</li></ol><table><thead><tr><th align="left">检测是否读取了过期的 MVCC对象</th><th align="left">检测写是否影晌了之前的读</th></tr></thead><tbody><tr><td align="left"><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/mvcc1.png" width=600/></td><td align="left"><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/transaction/mvcc2.png" width=600/></td></tr><tr><td align="left">为什么要等到提交: 当检测到读旧值，为何不立即中止事务43呢? <br>如果事务43是个只读事务，没有任何写倾斜风险，就不需要中止。 <br>事务提交时，有可能事务42发生了中止或者还处于未提交状态，因此读取的并非是过期值。</td><td align="left">1.事务42和事务43都在查询轮班 1234期间的值班医生。数据库可以通过索引条目1234来记录事务42和事务43都查询了相同的结果。该额外记录只需保留很小一段时间，当并发的所有事务都处理完成(提交或中止)之后，就可以丢弃。<br>2.当另一个事务尝试修改时，它首先检查索引，从而确定是否最近存在一些读目标数据的其他事务。这个过程类似于在受影响的宇段范围上获取写锁，但它并不会阻塞读取，而是直到读事务提交时才进一步通知他们 : 所读到的数据现在已经发生了变化。 <br>3.事务43和事务42会互相通知对方先前的读已经过期。虽然事务43的修改的确影响了事务42，但事务43当时并未提交(修改未生效)， 而事务42首先尝试提交，所以可以成功；随后当事务43试图提交时，来自事务42的冲突写已经提交生效，事务43不得不中止。</td></tr></tbody></table><div class="note info"><h4 id="串行化快照隔离的优点是什么："><a href="#串行化快照隔离的优点是什么：" class="headerlink" title="串行化快照隔离的优点是什么："></a>串行化快照隔离的优点是什么：</h4><ol><li>与两阶段加锁相比，可串行化快照隔离事务不需要等待其他事务所持有的锁。这一点和快照隔离一样 ，读写通常不会互相阻塞。</li><li>与严格串行执行相比，可串行化快照隔离可以突破单个CPU核的限制。</li><li>这样的设计使得查询延迟更加稳定、可预测。</li><li>在一致性快照上执行只读查询不需要任何锁，这对于读密集的负载非常有吸引力。</li></ol></div><h1 id="防止更新丢失"><a href="#防止更新丢失" class="headerlink" title="防止更新丢失"></a>防止更新丢失</h1><p>更新丢失发生的场景：<br>应用程序从数据库读取某些值，根据应用逻辑做出修改，然后写回新值。<br>即：read-modify-write</p><h2 id="更新丢失常见的解决方案"><a href="#更新丢失常见的解决方案" class="headerlink" title="更新丢失常见的解决方案"></a>更新丢失常见的解决方案</h2><table><thead><tr><th align="left">解决方案</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">原子写操作</td><td align="left"><code>UPDATE counters SET value = value + 1 WHERE key = &quot;foo&quot;;</code></td></tr><tr><td align="left">显式加锁</td><td align="left"><code>SELECT * FROM student WHERE name = &#39;zhangsan&#39; FOR UPDATE;</code></td></tr><tr><td align="left">原子比较和设置</td><td align="left"><code>UPDATE wiki SET content = &#39;new_content&#39; WHERE id = 1234 AND content = &#39;old_content&#39;;</code></td></tr><tr><td align="left">自动检测更新丢失</td><td align="left">数据库完全可以借助快照级别隔离来高效地执行检查（SSI）。<br>但是MySQL&#x2F;InnoDB的可重复读并不支持检测更新丢失</td></tr></tbody></table><div class="note danger"><p>Q：第三点CAS可靠吗？应用层是不是需要兼容？<br>A：不可靠，如果update失败，则应用层不能盲目的将新数据丢弃，而是应该检测冲突并解决。【或告知用户，本次更新操作存在冲突，需要重新提交】</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="left">问题</th><th align="left">详细解释</th><th align="left">解决方案</th></tr></thead><tbody><tr><td align="left">脏写</td><td align="left">客户端覆盖了另一个客户端尚未提交的写入。</td><td align="left">几乎所有的数据库实现都可以防止脏写。</td></tr><tr><td align="left">脏读</td><td align="left">客户端读到了其他客户端尚未提交的写人。</td><td align="left">读-提交以及更强的隔离级别可以防止脏读 。</td></tr><tr><td align="left">读倾斜(不可重复读)</td><td align="left">客户在不同的时间点看到了不同值。</td><td align="left">可重复读（快照隔离）是最用的防范手段， 即事务总是在某个时间点的一致性快照中读取数据。通常采用多版本井发控制( MVCC )来实现快照隔离。</td></tr><tr><td align="left">幻读</td><td align="left">事务读取了某些符合查询条件的对象，同时另一个客户端执行写入，改变了先前的查询结果。</td><td align="left">快照隔离可以防止简单的幻读（只读查询）。</td></tr><tr><td align="left">写倾斜</td><td align="left">事务首先查询数据，根据返回的结果而作出某些决定，然后修改数据库 。当事务提交时，支持决定的前提条件已不再成立。</td><td align="left">只有可串行化的隔离才能防止这种异常。</td></tr><tr><td align="left">更新丢失</td><td align="left">两个客户端同时执行【读-修改-写入】操作，出现了其中一个覆盖了另一个的写入，但又没有包含对方最新值的情况，最终导致了部分修改数据发生了丢失。</td><td align="left">快照隔离的一些实现（SSI）可以自动防止这种异常。或手动锁定查询结果(SELECT FOR UPDATE)。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内Github加速</title>
      <link href="/2020/11/12/Github-broker/"/>
      <url>/2020/11/12/Github-broker/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们从Github克隆仓库的时候，往往速度会比较慢，比如我克隆hadoop书籍对应的源代码，速度一致都是3KB左右，简直不能忍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tomwhite/hadoop-book.git</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>发现一个代理加速地址 hub.fastgit.org</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>将<code>github.com</code>替换为<code>hub.fastgit.org</code>   </p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tomwhite/hadoop-book.git</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://hub.fastgit.org/tomwhite/hadoop-book.git</span><br></pre></td></tr></table></figure><p>享受飞一般的速度</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven关闭Http强制代理</title>
      <link href="/2020/10/12/Maven-Http/"/>
      <url>/2020/10/12/Maven-Http/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天使用Maven编译项目的时候出现如下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WARNING] Could not validate integrity of download from http://0.0.0.0/</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Maven3.8.1以上版本针对http开头的仓库，强制会进行一层本地代理</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>方案一、降低版本到3.8.1以下<br>方案二、修改{maven-install-path}下的settings.xml文件。注释掉以下内容即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我用homebrew安装的maven，对应的路径是【&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;maven&#x2F;3.8.2&#x2F;libexec&#x2F;conf】</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【问题梳理】AmazonS3文件名包含英文括号导致401</title>
      <link href="/2020/04/15/Amazon-S3-401/"/>
      <url>/2020/04/15/Amazon-S3-401/</url>
      
        <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>通过S3上传文件，如果存储文件名中有英文括号，则S3服务端会返回鉴权失败【401】。出现问题的代码如下所示：</p><span id="more"></span><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/1.png" width=600/><h1 id="S3文件上传流程"><a href="#S3文件上传流程" class="headerlink" title="S3文件上传流程"></a>S3文件上传流程</h1><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/S3-framework.png" width=600/><h1 id="出现问题的地方"><a href="#出现问题的地方" class="headerlink" title="出现问题的地方"></a>出现问题的地方</h1><p>org.apache.http.client.utils.URIUtils#rewriteURI</p><table><thead><tr><th>阶段</th><th>URL</th></tr></thead><tbody><tr><td>S3生成权限校验签名</td><td><code>http://s3/bk/sam%28t%29hh.txt</code></td></tr><tr><td>Request请求</td><td><code>http://s3/bk/sam(t)hh.txt</code></td></tr></tbody></table><p>导致鉴权失败，返回401。</p><h1 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h1><h2 id="本来Request中的uri是http-s3-bk-sam-28t-29hh-txt，为什么apache会进行rewrite？"><a href="#本来Request中的uri是http-s3-bk-sam-28t-29hh-txt，为什么apache会进行rewrite？" class="headerlink" title="本来Request中的uri是http://s3/bk/sam%28t%29hh.txt，为什么apache会进行rewrite？"></a>本来Request中的uri是<code>http://s3/bk/sam%28t%29hh.txt</code>，为什么apache会进行rewrite？</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/2.png" width=600/>rewrite的逻辑如上图所示，主要目的是去除url中的无效路径。同时，我们通过代码可以看出，无论是否有空节点，最终都会执行uribuilder.setPathSegment(pathSegments);  在4.5.10中已经解决了这个问题，如果发现并没有进行空节点的remove操作，这里就不会执行uribuilder.setPathSegment(pathSegments);  <h2 id="rewrite的具体流程是什么"><a href="#rewrite的具体流程是什么" class="headerlink" title="rewrite的具体流程是什么"></a>rewrite的具体流程是什么</h2><p>可以详细看看【图3】中的setPathSegment干了什么：将encodedPath设置为null;<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/3.png" width=600/></p><p>在进行【图3】中所示的uribuilder.build操作的时候，如下图所示，会对pathSetment重新进行encodePath。<br>[“bk”,”sam(t)hh.txt”] [“bk”,”sam(t)hh.txt”]<br>本例中，pathSetment包含两个元素 [“bk”,”sam(t)hh.txt”]<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/5.png" width=600/></p><p>encodePath最终调用的是org.apache.http.client.utils.URLEncodedUtils#urlEncode方法<br>这里就很明显了，如果是在safechars集合中的字符，则不需要进行转码。<br>这里的safechars &#x3D; PATHSAFE如，PATHSAFE 包含 UNRESERVED<br>根据<a href="https://www.ietf.org/rfc/rfc2396.txt">RFC-2396</a>标准UNRESERVED应该包含英文括号，即英文括号不需要被转码。<br>如下图所示</p><table><thead><tr><th>PATHSAFE</th><th>UNRESERVED</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/6.png" width=600/></td><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/7.png" width=600/></td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/8.png" width=400/></td><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/9.png" width=300/></td></tr></tbody></table><p>所以进行uribuilder.build之后，pathSetment包含的两个元素 [“bk”,”sam(t)hh.txt”]，所有字符都不会被转码，生成的最终uri就成了：<code>http://s3/bk/sam(t)hh.txt</code>。</p><h2 id="S3在创建HttpRequest的时候，英文括号为什么会被转码：http-s3-bk-sam-28t-29hh-txt"><a href="#S3在创建HttpRequest的时候，英文括号为什么会被转码：http-s3-bk-sam-28t-29hh-txt" class="headerlink" title="S3在创建HttpRequest的时候，英文括号为什么会被转码：http://s3/bk/sam%28t%29hh.txt"></a>S3在创建HttpRequest的时候，英文括号为什么会被转码：<code>http://s3/bk/sam%28t%29hh.txt</code></h2><p>S3生成的URI，是经过Java原生的UrlEncoder进行encode的：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/11.png" width=600/></p><p>这里不需要转码的集合【dontNeedEncoding】如下所示：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/12.png" width=400/></p><p>其中不包含英文括号，所以英文括号也会被转码，导致生成的URI就是：<code>http://s3/bk/sam%28t%29hh.txt</code><br>然后S3-Client认为该URI【<code>http://s3/bk/sam%28t%29hh.txt</code>】就是需要访问的资源，通过该URI生成权限签名Sign-Auth。<br>但是最终Apache-client经过rewrite之后的Uri却是：【<code>http://s3/bk/sam(t)hh.txt</code>】, 所以S3的会报权限异常401【Sign-Auth与真实访问的资源URI不匹配】。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>这个问题在apache的httpclient 4.5.10版本中已经没有出现了。原因如下：<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Amazon-S3-401/13.png" width=600/></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>其实这个问题的本质在于：</p><h2 id="S3生成url鉴权的时候，用的Java-UrlEncoder。对英文括号要进行转码。"><a href="#S3生成url鉴权的时候，用的Java-UrlEncoder。对英文括号要进行转码。" class="headerlink" title="S3生成url鉴权的时候，用的Java-UrlEncoder。对英文括号要进行转码。"></a>S3生成url鉴权的时候，用的Java-UrlEncoder。对英文括号要进行转码。</h2><h2 id="底层执行http请求的时候用的-Apache-httpclient，会对uri进行rewrite，不会对英文括号进行转码。"><a href="#底层执行http请求的时候用的-Apache-httpclient，会对uri进行rewrite，不会对英文括号进行转码。" class="headerlink" title="底层执行http请求的时候用的 Apache-httpclient，会对uri进行rewrite，不会对英文括号进行转码。"></a>底层执行http请求的时候用的 Apache-httpclient，会对uri进行rewrite，不会对英文括号进行转码。</h2><p>导致异常。<br>apache 4.5.10以前，不论是否有空节点，都会进行setPathSegments，从而导致重新encode。【对英文括号不转码】<br>apache 4.5.10及以后，如果路径中没有空节点，就不会进行setPathSegments，直接沿用原来的encodePath。</p>]]></content>
      
      
      <categories>
          
          <category> S3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO(上) BIO、NIO、AIO介绍</title>
      <link href="/2019/10/12/Java-IO/"/>
      <url>/2019/10/12/Java-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="在开始之前"><a href="#在开始之前" class="headerlink" title="在开始之前"></a>在开始之前</h1><h2 id="这个系列的概要"><a href="#这个系列的概要" class="headerlink" title="这个系列的概要"></a>这个系列的概要</h2><p>这个系列主要是讲Java-IO，分为上中下三篇。</p><ol><li>上篇主要是介绍Java原生的<strong>BIO(IO),NIO,AIO(NIO2)</strong></li><li>中篇主要是介绍经典的IO框架<strong>Netty</strong>的基本概念，以及线程模型</li><li>下篇则是讲<strong>Netty</strong>的项目实践，如何用<strong>Netty</strong>实现一套<strong>RPC</strong>框架</li></ol><span id="more"></span><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>在介绍Java原生IO，以及Netty框架的时候，我都会以一个简单的HttpServer作为Demo。<br>所以在本系列中会包含四个版本的HttpServer（BIO，NIO，AIO，Netty）。<br>其中BIO，NIO，AIO版本的Demo未引入任何第三方包，只需要JDK8+即可运行。<br>Netty版本的Demo需要配置第三方依赖，对应的maven配置在中篇会单独列出。</p><hr><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>本篇主要是对Java原生IO（BIO、NIO、AIO）进行介绍，同时进行对比。<br>为了给大家一个直观快速的感受，我们分别用这几种不同的IO方式，来写一个简单的HttpServer，这个HttpServer的主要功能就是，将浏览器的请求内容，原封不动的返回给浏览器。可能代码里面的部分API大家可能已经忘记了，不过不要紧，后面会对比较重要的部分进行详细的讲解。</p><h2 id="BIO版本HttpServer"><a href="#BIO版本HttpServer" class="headerlink" title="BIO版本HttpServer"></a>BIO版本HttpServer</h2><p>Java的BIO（IO）很简单，直接面向socket编程，每当接收到一个新的socket，都新建一个线程进行处理。当然了，处理线程也可以设计成线程池，可以在一定程度上提高性能。<br><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/1-Java-bio-thread.png" width=400/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 用一个线程池处理接收到的请求</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 服务端开启8081端口</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8081</span>);</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞式接收请求</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">      <span class="comment">// 每当有新的请求到来，将其放到线程池中处理</span></span><br><span class="line">      executor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 从inputStream中读取输入内容</span></span><br><span class="line">          <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">          inputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 封装输出内容，并将其写到outputStream</span></span><br><span class="line">          writer.write(ResponseUtils.getResponse(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8)));</span><br><span class="line">          writer.flush();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里需要分别关闭输入和输出，否则浏览器请求的时候会发生异常</span></span><br><span class="line">          <span class="comment">// 思考1：为什么不能直接close</span></span><br><span class="line">          accept.shutdownInput();</span><br><span class="line">          accept.shutdownOutput();</span><br><span class="line">          accept.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><h5 id="思考一，shutdownInput，shutdownOutput-的作用是什么？"><a href="#思考一，shutdownInput，shutdownOutput-的作用是什么？" class="headerlink" title="思考一，shutdownInput，shutdownOutput 的作用是什么？"></a>思考一，shutdownInput，shutdownOutput 的作用是什么？</h5><p>因为socket是双向的，需要先关闭输入流，告诉客户端，我不再接收数据，然后关闭输出流，表示我的数据已经发送完毕。<br>详细信息可以参考如下<a href="https://blog.csdn.net/dabing69221/article/details/17351881">【Java TCP&#x2F;IP Socket】 — close()&#x2F;shutdownOutput()&#x2F;shutdownInput() 分析</a></p></div><h2 id="NIO版本HttpServer"><a href="#NIO版本HttpServer" class="headerlink" title="NIO版本HttpServer"></a>NIO版本HttpServer</h2><p>NIO是本章重点介绍内用，因为是对后续的Netty框架介绍做铺垫，所以这里会讨论以下内容：</p><ol><li>Channel</li><li>Buffer</li><li>Selector</li><li>为什么用NIO</li></ol><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/2-Java-nio-thread.png" width=300/><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 全局selector，至关重要</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 服务端开启对8082端口的监听</span></span><br><span class="line">    ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8082</span>));</span><br><span class="line">    <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    <span class="comment">// 思考1：阻塞和同步是一个概念吗？非阻塞=异步？</span></span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 注册监听到selector上</span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">// 因为是非阻塞模式，所以不论是否接收到请求，selector.select()都会立即返回。这里需要判断是否真正的accept</span></span><br><span class="line">      <span class="keyword">if</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理接收到的事件</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 注册读事件</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 我们不会直接从channel中取出字节，而是将channel中的数据写入Buffer缓冲区</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">result</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">102400</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 从buffer读数据之前，进行flip操作。</span></span><br><span class="line">              <span class="comment">// 思考2：为什么从buffer读数据要先进行flip操作</span></span><br><span class="line">              buffer.flip();</span><br><span class="line">              result.put(buffer);</span><br><span class="line">              <span class="comment">// 思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)</span></span><br><span class="line">              buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续注册写事件</span></span><br><span class="line">            sc.register(selector, SelectionKey.OP_WRITE, <span class="keyword">new</span> <span class="title class_">String</span>(result.array(), StandardCharsets.UTF_8));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">String</span> <span class="variable">attachment</span> <span class="operator">=</span> (String) key.attachment();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(ResponseUtils.getResponse(attachment).getBytes());</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">              sc.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回写数据完成，关闭channel</span></span><br><span class="line">            sc.close();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><h5 id="思考1：阻塞和同步是一个概念吗？非阻塞-异步？"><a href="#思考1：阻塞和同步是一个概念吗？非阻塞-异步？" class="headerlink" title="思考1：阻塞和同步是一个概念吗？非阻塞&#x3D;异步？"></a>思考1：阻塞和同步是一个概念吗？非阻塞&#x3D;异步？</h5><p>这种概念性的问题没必要太关注，有点像回字有多少种写法，关键的还是要能够理解IO模型的原理。<br>这里只是简单提一下。通过<a href="https://samforit.github.io/2019/11/02/Unix-IO/">Unix的五种IO模型介绍</a> 我们可以知道：<br>1.BIO是阻塞式IO，是同步IO，这点是没有异议的<br>2.NIO可以设置两种模式：阻塞模式（Unix多路复用IO）和非阻塞模式（Unix非阻塞IO），但数据从内核态加载为用户态的这个过程，是同步的，所以NIO也是同步的。<br>3.AIO(后面会进行讨论)是完全的非阻塞模式，也是真正的异步IO。<br>综上：<br>非阻塞，对于底层Unix-IO模型，都是指数据从磁盘加载到内核态的这个过程，是否阻塞。<br>异步是指整个IO操作（包含了两步：数据在内核态准备完成，数据从内核态转变为用户态）完成之后，系统通知应用程序（通过signal或callback）。</p></div><div class="note info"><h5 id="思考2：为什么从buffer读数据要先进行flip操作"><a href="#思考2：为什么从buffer读数据要先进行flip操作" class="headerlink" title="思考2：为什么从buffer读数据要先进行flip操作"></a>思考2：为什么从buffer读数据要先进行flip操作</h5><p>buffer底层就是一个数组，我们需要当写数据的时候我们需要记录从何处开始写（position），以及数组的最大容量（capacity）。<br>当我们读数据的时候，需要知道当前数组有多少个元素可读（limit），以及记录当前已经读到了哪个位置（position）。<br>所以当读写模式转换的时候，我们就需要对buffer进行flip（写转读），clear（读转写）操作。详见【NIO Buffer】章节<br>以上只是一般性操作，不代表所有应用场景。</p></div><div class="note info"><h5 id="思考3：为什么向buffer写数据要先进行clear操作-新建的buffer不需要"><a href="#思考3：为什么向buffer写数据要先进行clear操作-新建的buffer不需要" class="headerlink" title="思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)"></a>思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)</h5><p>同思考2</p></div><h3 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h3><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/2-nio-channel.png" width=300/>channel在NIO中的地位，和流在BIO中的地位类似。但有以下不同点：<table><thead><tr><th>区别</th><th>Channel</th><th>流（InputStream，OutputStream）</th></tr></thead><tbody><tr><td>方向</td><td>双向的</td><td>一般来说都是单向的</td></tr><tr><td>异步</td><td>支持异步操作【AIO就是典型的例子】</td><td>只支持同步操作</td></tr><tr><td>对接</td><td>一般不能直接从channel读写数据，channel只和缓冲区Buffer交互</td><td>直接对流进行读写</td></tr></tbody></table><h3 id="NIO-Buffer"><a href="#NIO-Buffer" class="headerlink" title="NIO Buffer"></a>NIO Buffer</h3><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/2-nio-buffers-modes.png" width=400/><table><thead><tr><th></th><th>向缓冲区写数据时</th><th>从缓冲区读数据时</th></tr></thead><tbody><tr><td><strong>position</strong></td><td>记录当前已经在buffer中写入了多少数据，指向下一个即将写入数据的坑位。举例，如果当前从缓冲区读取7个元素，则当前缓冲区的position的值为7，指向第8个元素的位置。</td><td>记录当前从buffer中读取了多少数据，指向下一个即将读取的元素。举例，如果当前已经从缓冲区读取了4个元素，那么缓冲区的position将被设置为4，指向第5个元素。</td></tr><tr><td><strong>limit</strong></td><td>一般来说limit等于capacity。</td><td>记录最后一个可读取元素的位置。</td></tr><tr><td><strong>capacity</strong></td><td>表示缓冲区的最大容量。</td><td>表示缓冲区的最大容量。</td></tr></tbody></table><p>有一篇文章对buffer内部结构的介绍很详细，可以参考：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">IBM-NIO入门</a></p><h3 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h3><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/2-Java-nio-thread.png" width=300/><p>Selector基于操作系统底层的epoll，一个Selector可以同时监听多个Channel上的事件，不必对每一个连接都新建一个线程。</p><div class="note danger"><h3 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h3><p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I&#x2F;O 而无需编写自定义的本机代码。NIO 将最耗时的 I&#x2F;O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。<br>NIO的出现，使得当IO未就绪时，线程可以不挂起，继续处理其他事情。一个线程也不必局限于只为一个IO连接服务。</p></div><p>BIO与NIO的线程模型对比：</p><table><thead><tr><th><strong>BIO模型</strong></th><th><strong>NIO模型</strong></th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/nio-vs-io-1.png" width=300/></td><td><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Java-IO/nio-vs-io-2.png" width=400/></td></tr><tr><td>IO以流的方式处理数据</td><td>NIO 以块的方式处理数据</td></tr><tr><td>面向流的IO系统一次一个字节地处理数据，通过过滤器，处理流程很优雅</td><td>每一个操作都在一步中产生或者消费一个数据块，缺少流式处理的优雅性与简单性</td></tr><tr><td>面向流的IO通常相当慢</td><td>按块处理数据比按流处理要快得多</td></tr></tbody></table><h2 id="AIO版本HttpServer"><a href="#AIO版本HttpServer" class="headerlink" title="AIO版本HttpServer"></a>AIO版本HttpServer</h2><p>应用程序完全不用关心IO何时准备好，这一切都交给操作系统（IO的两个阶段）。<br>同时给操作系统提供一个缓冲区，当数据往缓冲区写好之后，通知应用程序即可。</p><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/5-AIO.jpg" width=600/><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 服务端启动8083端口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8083</span>));</span><br><span class="line">    channel.accept(channel, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel client, AsynchronousServerSocketChannel attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 思考1：accept again，why？</span></span><br><span class="line">        attachment.accept(attachment, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一块缓冲区，将客户端的数据写入缓冲区中。</span></span><br><span class="line">        <span class="comment">// 思考2：这样有什么缺点</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        client.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result_num, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 准备冲缓冲区读数据，老规矩，先进行flip</span></span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(body);</span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> ResponseUtils.getResponse(<span class="keyword">new</span> <span class="title class_">String</span>(body, StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(response.getBytes());</span><br><span class="line">            <span class="comment">// 数据回写</span></span><br><span class="line">            client.write(writeBuffer, writeBuffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 回写数据完成，关闭连接</span></span><br><span class="line">                  client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;<span class="comment">/** write fail 咋办 */</span>&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;<span class="comment">/** read fail 咋办 */</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, AsynchronousServerSocketChannel attachment)</span> &#123;<span class="comment">/** accept fail 咋办 */</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 思考3：这行代码的必要性</span></span><br><span class="line">    System.in.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><h5 id="思考1：accept-again，why？"><a href="#思考1：accept-again，why？" class="headerlink" title="思考1：accept again，why？"></a>思考1：accept again，why？</h5><p>因为AIO是异步模型，当接收到请求之后，当前线程就退出了，所以当接收到请求之后，需要再次注册服务端的accept操作。</p></div><div class="note info"><h5 id="思考2：read数据之前，先分配缓冲区，这样有什么缺点"><a href="#思考2：read数据之前，先分配缓冲区，这样有什么缺点" class="headerlink" title="思考2：read数据之前，先分配缓冲区，这样有什么缺点"></a>思考2：read数据之前，先分配缓冲区，这样有什么缺点</h5><p>预分配缓冲区大小，需要按照最大请求的输入Body-size进行分配，所以对于一个Body比较小的请求，相当于资源浪费。</p></div><div class="note info"><h5 id="追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？"><a href="#追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？" class="headerlink" title="追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？"></a>追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？</h5><p>数据在Channel中是顺序读取的，如果接收数据的Buffer空间，小于Channel中实际的数据内容，比如，现在Channel中有4个字节[a,b,c,d]，但现在接受缓冲区数据的Buffer大小只有3个字节。<br>此时，只会读取前Channel中的前三个字节[a,b,c]到Buffer中，剩余的一个字节[d]仍留在Channel中，如果继续从Channel中读数据，可以将第四个字节读出来。<br>最后：如果Channel中有数据未读取，当Channel关闭的时候，里面的数据就被丢弃了。<br>由此我们可以看出：<br>java.nio.channels.AsynchronousSocketChannel#read(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;)<br>这个方法，以下两种情况满足任意一种都会认为数据读取完成，从而回调completed方法：<br>1.channel中的所有数据都已经读到Buffer中。<br>2.Buffer的可用空间已经被填满。</p></div><div class="note info"><h5 id="思考3：System-in-read-这行代码的必要性"><a href="#思考3：System-in-read-这行代码的必要性" class="headerlink" title="思考3：System.in.read(); 这行代码的必要性"></a>思考3：System.in.read(); 这行代码的必要性</h5><p>因为异步代码执行完成之后，线程就退出了，随之应用程序退出。<br>所以需要加上一行，主线程等待系统输入，避免程序退出。</p></div><div class="note info"><h5 id="AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？"><a href="#AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？" class="headerlink" title="AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？"></a>AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？</h5><p>1.服务器大多是Linux系统，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势。<br>2.AIO接收数据的时候需要预先分配缓冲区大小, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 会造成内存浪费</p></div><h2 id="以上代码中用到的工具类"><a href="#以上代码中用到的工具类" class="headerlink" title="以上代码中用到的工具类"></a>以上代码中用到的工具类</h2><p>主要就是封装Http-Header和Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CRLF</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getResponse</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    msg = <span class="string">&quot;Server response:&lt;br&gt;&lt;br&gt;&quot;</span> + msg.replaceAll(CRLF, <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;HTTP /1.1 200 ok &quot;</span>).append(CRLF)</span><br><span class="line">        .append(<span class="string">&quot;Content-Type:text/html &quot;</span>).append(CRLF)</span><br><span class="line">        .append(<span class="string">&quot;Content-Length:&quot;</span> + msg.length()).append(CRLF).append(CRLF)</span><br><span class="line">        .append(msg).toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h1><p>没有比这个更简明易懂的NIO教程了<br><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></p><p>IBM讲NIO的Buffer比较详细<br><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">IBM-NIO入门</a></p><p>AIO讲解<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/index.html">在 Java 7 中体会 NIO.2 异步执行的快乐</a></p>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix的五种IO模型介绍</title>
      <link href="/2019/10/11/Unix-IO/"/>
      <url>/2019/10/11/Unix-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前打算总结一下Java的<strong>BIO（IO），AIO，NIO</strong>，最后一步步深入，发现Unix（Linux）的IO模型需要提前掌握，所以先总结一下Unix的IO模型。</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Java-IO-与-Unix-IO-的关系（非严格对应）"><a href="#Java-IO-与-Unix-IO-的关系（非严格对应）" class="headerlink" title="Java IO 与 Unix IO 的关系（非严格对应）"></a>Java IO 与 Unix IO 的关系（非严格对应）</h2><p>Unix网络编程中介绍了五种IO模型，分别是：阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO。<br>Java的IO模型与Unix的IO模型的对应关系如下所示（这个对应关系并不严格）：</p><table><thead><tr><th>Java-IO模型</th><th>Unix-IO模型</th></tr></thead><tbody><tr><td>BIO</td><td>阻塞式IO</td></tr><tr><td>NIO</td><td>IO多路复用</td></tr><tr><td>AIO</td><td>异步IO</td></tr></tbody></table><h2 id="数据的内核态和用户态"><a href="#数据的内核态和用户态" class="headerlink" title="数据的内核态和用户态"></a>数据的内核态和用户态</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/linux-kernal-user.png" width=600/>在进行IO模型讲解之前，先讲讲数据的两个状态：内核态和用户态。我们将文件从磁盘加载到内存中。操作系统是怎么做的？第一步：因为我们的所有程序，都是和操作系统的内核进行交互，所以文件首先是从磁盘加载到内核，这时候文件是处于内核态。第二步：文件从内核再加载到内存中，应用程序此时才可以在内存中进行读写操作。这个时候的文件就是用户态。所以Unix的五种IO模型的不同指出，就是这两个步骤的处理流程不同。<h1 id="Unix五种IO模型分别介绍"><a href="#Unix五种IO模型分别介绍" class="headerlink" title="Unix五种IO模型分别介绍"></a>Unix五种IO模型分别介绍</h1><h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/1-BIO.jpg" width=600/>这种模式很简单，系统给调用**recvfrom**函数之后，线程一直处于等待状态，一直等到：第一步文件加载到内核态完成，第二步文件加载到用户态完成。<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/2-NIO.jpg" width=600/>系统不停的通过**recvfrom**进行轮询，一直到第一步完成，然后在第二步阻塞式的将数据从内核态加载到用户态。这里的非阻塞IO模式，主要是指第一步，加载数据到内核态，这个过程是非阻塞的，通过轮询来判断数据是否在内核准备好。<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/3-MIO.jpg" width=600/>系统首先通过select，阻塞式的查看内核数据是否准备完毕。当内核数据加载完成之后，系统会调用**recvfrom**，将内核态的数据加载到用户态。这里看起来第一步和第二步都是阻塞式操作，但是，select可以在极小代价的情况下，同时处理多个文件句柄（包括socket）。<h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/4-SIO.jpg" width=600/>第一步，相当于系统注册一个回调函数，当内核数据准备好了之后通知我。此时系统可以做其他的事情，并不需要阻塞式的等待内核数据。第二步，阻塞式调用**recvfrom**，将内核的数据加载到用户态。<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/5-AIO.jpg" width=600/>这个模型在理论上来说，是真正的异步模型，因为在以上四种模型中，在第二步：数据从内核态加载到用户态，都是同步操作。而在该模型中，系统在加载文件的时候，只需要通过aio_read注册一个回调，当文件完成了内核态，用户态的加载之后，通知当前系统。在这个过程中，系统不用等待，可以执行其他的运算任务。<h2 id="汇总对比"><a href="#汇总对比" class="headerlink" title="汇总对比"></a>汇总对比</h2><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/Unix-IO/6-IO.jpg" width=600/>这张图是对以上五种IO模型的汇总比较，总的来说，越靠后的模型在理论上来说就越高效。前面的四种IO模型【阻塞IO、非阻塞IO、IO多路复用、信号驱动IO】，都属于同步IO，只有最后一种模型是真正的异步【异步IO】<h1 id="系统调用介绍"><a href="#系统调用介绍" class="headerlink" title="系统调用介绍"></a>系统调用介绍</h1><div class="note warning"><h3 id="1-Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？"><a href="#1-Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？" class="headerlink" title="1.Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？"></a>1.Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？</h3><p>因为select是轮询的模式，不停的检查文件句柄的状态。<br>epoll是callback的模式，当文件句柄准备好了之后，直接进行回调，更高效。</p></div><div class="note warning"><h3 id="2-Java有真正的AIO模式吗？"><a href="#2-Java有真正的AIO模式吗？" class="headerlink" title="2.Java有真正的AIO模式吗？"></a>2.Java有真正的AIO模式吗？</h3><p>在Windows系统下，通过IOCP实现。<br>在Linux系统下，没有，因为Linux系统下的AIO底层仍是epoll。<br>（个人猜测，这也是为什么Netty使用了NIO，而没有使用AIO）</p></div><h1 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h1><p>以对话的形式讲述，比较易于理解<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect">漫话：如何给女朋友解释什么是Linux的五种IO模型？</a></p><p>数据的内核态，用户态，这篇文章也有讲到，同时介绍了高效的数据传输方式：zero-copy<br><a href="https://blog.csdn.net/u013256816/article/details/52589524">zero-copy</a></p>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript模拟post表单提交</title>
      <link href="/2018/11/11/javascript-post-form/"/>
      <url>/2018/11/11/javascript-post-form/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天遇到一个问题，我在使用spring-security的时候，配置了登出链接：<code>&lt;logout logout-url=&quot;/logout&quot; logout-success-url=&quot;/&quot; /&gt;</code>.但是登出的button每当点击的时候就会报异常：服务器没有对应的方法（&#x2F;logout）。</p><span id="more"></span><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为在spring-security中默认开启了csrf，所以在提交表单的时候需要用一个隐藏button提交token，就以注册页面举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;basePath&#125;/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以对于登出接口也是一样，需要以post方式提交，并且加入token。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>专门写一个form表单，映射到退出的button上，这样不是不可以，但是不美观（对于前端技术，没有深入研究）。<br>所以我就想写一个js脚本，提交post请求，这个button就来调一下这个js函数就行了。<br>那么我的js脚本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postRequest</span>(<span class="params">path, params, method</span>) &#123;</span><br><span class="line">    method = method || <span class="string">&quot;post&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;form&quot;</span>);</span><br><span class="line">    form.<span class="title function_">setAttribute</span>(<span class="string">&quot;method&quot;</span>, method);</span><br><span class="line">    form.<span class="title function_">setAttribute</span>(<span class="string">&quot;action&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        <span class="keyword">if</span>(params.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> hiddenField = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">            hiddenField.<span class="title function_">setAttribute</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">            hiddenField.<span class="title function_">setAttribute</span>(<span class="string">&quot;name&quot;</span>, key);</span><br><span class="line">            hiddenField.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, params[key]);</span><br><span class="line"></span><br><span class="line">            form.<span class="title function_">appendChild</span>(hiddenField);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(form);</span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要登出的地方，进行如下调用即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:postRequest(&#x27;$&#123;basePath&#125;/logout&#x27;, &#123;&#x27;$&#123;_csrf.parameterName&#125;&#x27;: &#x27;$&#123;_csrf.token&#125;&#x27;&#125;);&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，搞定。<br>如有不对之处，还请各位赐教。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql blocked because of many connection errors</title>
      <link href="/2018/03/06/mysql-flush-hosts/"/>
      <url>/2018/03/06/mysql-flush-hosts/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天启动服务的时候，发现有一个服务一直启动不起来，报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by:</span><br><span class="line">java.sql.SQLException: null,</span><br><span class="line">message from server: &quot;Host &#x27;192.168.0.10&#x27; is blocked because of many connection errors; unblock with &#x27;mysqladmin flush-hosts&#x27;&quot;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里的错误已经很明确了，就说某一个ip产生了大量的错误链接，然后这个IP就被锁了，如果要解除锁定，就用mysql自带的名命令’mysqladmin flush-hosts’解锁即可。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol><li><p>通过提示，用命令’mysqladmin flush-hosts’。</p><blockquote><p>如果是远程机器，可以使用 :<br>mysqladmin flush-hosts -h 192.168.1.9 -P 3306 -u root -p</p></blockquote></li><li><p>进入mysql命令行，输入’flush hosts’也是可以的。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/mysql-flush-hosts/mysql-flush-hosts-1.png" width=600/></li><li><p>修改max_connection_errors</p><blockquote><p>查看：show variables like ‘max_connect_errors’;<br>修改：set global max_connect_errors &#x3D; 1000;<br>校验：show variables like ‘max_connect_errors’;</p></blockquote></li></ol><img src="https://cdn.jsdelivr.net/gh/samforit/pic@main/mysql-flush-hosts/mysql-flush-hosts-2.png" width=400/>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用crond构建linux定时任务及日志查看</title>
      <link href="/2018/03/02/linux-crond/"/>
      <url>/2018/03/02/linux-crond/</url>
      
        <content type="html"><![CDATA[<h1 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h1><ol><li>新建一个定时任务配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu ~]# vim /etc/cron.d/myTask</span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ol start="2"><li><p>编辑内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu ~]# cat /etc/cron.d/myTask</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前时间写入到<span class="built_in">log</span>文件,一小时执行一次</span></span><br><span class="line">0 * * * * root echo `date` &gt;&gt; /root/date.log</span><br></pre></td></tr></table></figure></li><li><p>重新载入配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu ~]# service crond reload</span><br></pre></td></tr></table></figure><p>搞定</p></li></ol><hr><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ol><li><p>定时任务配置文件可以放到<code>/etc/cron.d</code>文件夹下，reload 或 restart 的时候crond服务会扫描该文件夹下的文件。</p></li><li><p>定时任务配置：<br>执行时间(cron表达式) + 执行用户 + 任务</p><blockquote><p>示例： 0 * * * * root python &#x2F;root&#x2F;hello.py</p></blockquote></li><li><p>新增或修改定时任务配置后，需要reload才能生效。</p></li><li><p>服务相关命令：<br>service crond start    &#x2F;&#x2F;启动服务<br>service crond stop     &#x2F;&#x2F;关闭服务<br>service crond restart  &#x2F;&#x2F;重启服务<br>service crond reload   &#x2F;&#x2F;重新载入配置<br>service crond status   &#x2F;&#x2F;查看服务状态</p></li></ol><hr><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ol><li><p>查看任务有没有运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu ~]# tail -2 /var/log/cron</span><br><span class="line">Dec 15 06:00:01 ubuntu CROND[28783]: (root) CMD (echo `date` &gt;&gt; /root/date.log)</span><br><span class="line">Dec 15 06:01:01 ubuntu CROND[28923]: (root) CMD (echo `date` &gt;&gt; /root/date.log)</span><br></pre></td></tr></table></figure></li><li><p>如果运行中报错等，会有邮件记录，在此处查看详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu ~]# tail -2 /var/spool/mail/root</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crond </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>classpath和classpath*的区别</title>
      <link href="/2017/12/01/classpath-asterisk/"/>
      <url>/2017/12/01/classpath-asterisk/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在我们在开发一套OA系统，用到了springMVC，我们的spring相关配置文件统一放在<code>src/main/resources/spring</code> 文件夹下面，web.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/application-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们现在需要用到一个定时任务管理系统，是公司另一个部门开发的，通过maven dependence的方式引入，该jar包中也有spring相关的配置文件，路径为：<code>spring/application-task</code>。但是项目启动的时候，这个配置文件却没有加载进来。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>后面将web.xml的配置修改了一下，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/application-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我认为，classpath就是加载当前项目下的资源文件。<br>而classpath*就是加载包含jar包在内的所有依赖的资源文件。<br>后续看了源代码，继续进行深入分析，这里只是打一个标记，算是给遇到该问题的人一个出坑的思路。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
